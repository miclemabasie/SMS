from io import BytesIO
from django.shortcuts import redirect, reverse, HttpResponse
from django.contrib import messages
from django.template.loader import get_template
from django.contrib.auth.decorators import login_required

from pypdf import PdfMerger
from weasyprint import HTML

from apps.reports.student_reporting import ClassPerformanceReport
from apps.students.models import Class, StudentProfile
from apps.terms.models import AcademicYear, ExaminationSession, Term
from apps.settings.models import Setting


def generate_pdf(request):
    # Dummy data for demonstration
    context = {
        "title": "Sample PDF Generated by WeasyPrint",
        "content": "This is a simple PDF generated by WeasyPrint in Django.",
        "moto": "Republic of Cameroon",
        "school_name": "Ikom Institute of technology",
    }

    # # Rendered HTML template as string
    # html_string = render_to_string("reports/gpt-report-design.html", context)

    # # Generate PDF file
    # pdf_file = HTML(string=html_string).write_pdf()

    # # HTTP response with PDF download
    # response = HttpResponse(pdf_file, content_type="application/pdf")
    # response["Content-Disposition"] = 'attachment; filename="sample_pdf.pdf"'
    return context


@login_required
def create_report_cards(request):
    if request.method == "POST":
        selected_class_id = request.POST.get("selected_class_id")

        # get class
        classes = Class.objects.filter(pkid=selected_class_id)
        term = Term.objects.get(is_current=True)

        performance_obj = ClassPerformanceReport(selected_class_id, term.pkid)
        setup = performance_obj.setup()
        if setup:
            messages.error(request, setup)
            return redirect(reverse("reports:reports"))

        # check if class has any subject attached to it, if not, return.
        if len(performance_obj.sub_dicts) < 1:
            messages.warning(request, "No subjects associated with the given class.")
            return redirect(reverse("reports:reports"))

        if performance_obj.get_total_students_per_class() < 1:
            messages.warning(request, "No students for the given class.")
            return redirect(reverse("reports:reports"))

        # Get all students for the class
        students = performance_obj.get_all_students_for_current_class()

        academic_year = AcademicYear.objects.filter(is_current=True).first()
        term = performance_obj.get_term()
        sessions = ExaminationSession.objects.filter(term=term)

        # Initialize a PdfMerger object to merge all PDFs
        pdf_merger = PdfMerger()

        class_performance_data = performance_obj.generate_performacne_rank_list()
        class_performance = class_performance_data["class_performance"]

        class_avg = performance_obj.get_class_avg()
        setting = Setting.objects.all().first()

        for student in students:
            student_marks = performance_obj.generate_student_report_data(student)
            student_ranking = performance_obj.get_student_rank(
                student, class_performance
            )

            pdf_data = {
                "marks": student_marks["data"],
                "student_data": student_marks,
                "term": term,
                "term_name": term.term.upper(),
                "sessions": sessions,
                "year": academic_year,
                "student_rank": student_ranking,
                "class_total": len(students),
                "class_avg": class_avg,
                "setting": setting,
                "student": student,
            }

            context = {"data": pdf_data}
            template_path = "reports/gpt-report-design.html"
            template = get_template(template_path)
            html = template.render(context)

            # Generate PDF for current student
            pdf_file = BytesIO()
            HTML(string=html).write_pdf(pdf_file)
            pdf_file.seek(0)

            # Append current student's PDF to the PdfMerger object
            pdf_merger.append(pdf_file)

            # Reset pdf_file to write a new PDF for the next student
            pdf_file.close()

            performance_obj.create_student_academic_records(
                student, student_marks, student_ranking
            )

        # Finalize the merged PDF and serve as the response
        merged_pdf_file = BytesIO()
        pdf_merger.write(merged_pdf_file)
        merged_pdf_file.seek(0)

        response = HttpResponse(content_type="application/pdf")
        response["Content-Disposition"] = (
            f'attachment; filename="{performance_obj.generate_file_name()}-report-cards.pdf"'
        )
        response.write(merged_pdf_file.getvalue())
        merged_pdf_file.close()

        return response

    else:
        return redirect("reports:reports")


@login_required
def create_one_report_card(request, *args, **kwargs):

    if request.method == "POST":

        selected_student_id = request.POST.get("selected_student_id")
        selected_term_id = request.POST.get("selected_term_id")
        if not selected_student_id:
            messages.error(request, "Invalid or empty student ID")
            return redirect(reverse("reports:reports"))

        if not selected_term_id:
            messages.error(request, "Invalid or missing term ID")
            return redirect(reverse("reports:reports"))

        # Get the student
        student = StudentProfile.objects.filter(pkid=selected_student_id).first()
        if not student:
            messages.error(request, "No student with the given ID found.")
            return redirect(reverse("reports:reports"))

        if len(student.get_all_subjects()) < 1:
            messages.error(request, "No subjects associated with this student.")
            return redirect(reverse("reports:reports"))

        # Get the current year and term
        academic_year = AcademicYear.objects.filter(is_current=True).first()
        term = Term.objects.get(pkid=selected_term_id)
        klass = student.current_class

        # Instantiate a performance object
        performance_obj = ClassPerformanceReport(klass.pkid, term.pkid)
        setup = performance_obj.setup()
        if setup:
            messages.error(request, setup)
            return redirect(reverse("reports:reports"))

        sessions = ExaminationSession.objects.filter(term=term)

        # Generate student report data
        student_marks = performance_obj.generate_student_report_data(student)
        if not student_marks:
            messages.error(request, "Unset terms")
            return redirect(reverse("reports:reports"))

        class_performance_data = performance_obj.generate_performacne_rank_list()
        class_performance = class_performance_data["class_performance"]
        student_ranking = performance_obj.get_student_rank(student, class_performance)
        class_avg = performance_obj.get_class_avg()
        setting = Setting.objects.all().first()

        # Prepare the context data
        pdf_data = {
            "marks": student_marks["data"],
            "student_data": student_marks,
            "term": term,
            "term_name": term.term.upper(),
            "sessions": sessions,
            "year": academic_year,
            "student_rank": student_ranking,
            "class_total": performance_obj.get_total_students_per_class(),
            "class_avg": class_avg,
            "setting": setting,
            "student": student,
        }
        context = {"data": pdf_data}

        # Generate PDF
        template_path = "reports/gpt-report-design.html"
        template = get_template(template_path)
        html = template.render(context)

        pdf_file = BytesIO()
        HTML(string=html).write_pdf(pdf_file)
        pdf_file.seek(0)

        response = HttpResponse(content_type="application/pdf")
        response["Content-Disposition"] = (
            f'attachment; filename="{student.user.first_name}-report.pdf"'
        )
        response.write(pdf_file.getvalue())
        pdf_file.close()

        return response

    else:
        return redirect(reverse("reports:reports"))
